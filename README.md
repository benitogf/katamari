# samo

[![Build Status][build-image]][build-url]


[build-url]: https://travis-ci.org/benitogf/samo
[build-image]: https://api.travis-ci.org/benitogf/samo.svg?branch=master&style=flat-square

Dynamic websocket and restful http service with a data persistence layer, it allows quick prototyping of realtime applications providing an interface with no fixed data structure or access regulations, but capable of [defining them](https://github.com/benitogf/samo#filters-and-audit) if necessary.

A very nice article with some [similar solutions](https://medium.com/@brenda.clark/firebase-alternative-3-open-source-ways-to-follow-e45d9347bc8c).

# quickstart

## client

There's a [js client library](https://www.npmjs.com/package/samo-js-client).

also a [react application example](https://github.com/benitogf/samo-js-client-example).

## server

with [golang installed](https://golang.org/doc/install) from a terminal get the library:

```bash
go get github.com/benitogf/samo
```

then create a file `main.go` with the code:
```golang
package main

import "github.com/benitogf/samo"

func main() {
	app := samo.Server{}
	app.Start("localhost:8800")
	app.WaitClose()
}
```

finally run the service with:
```bash
go run main.go
```

# Specs

| method | description | url    |
| ------------- |:-------------:| -----:|
| GET | key list | http://{host}:{port} |
| DELETE | del | http://{host}:{port}/r/{key} |

## time

server side time ticker. will send a new timestamp per second

| method | description | url    |
| ------------- |:-------------:| -----:|
| websocket| time ticker | ws://{host}:{port}/time |

## single allocation (sa)

will handle the key as key->value

| method | description | url    |
| ------------- |:-------------:| -----:|
| websocket| key data events: update, delete | ws://{host}:{port}/sa/{key} |
| POST | create/update | http://{host}:{port}/r/sa/{key} |
| GET | get object | http://{host}:{port}/r/sa/{key} |
### websocket

### get (sent after handshake and on each new/update/delete event)
---
```js
{
    created: 0,
    updated: 0,
    index: '',
    data: 'e30='
}
```

### set (format expected from client)
---
```js
{
    data: 'e30='
}
```

### del (format expected from client)
---
```js
{
    op: 'del'
}
```

## multiple objects (mo)

    will handle the key as a list of every key/[index...] (or key/*), excluding the empty index (key->value)

| method  | description | url    |
| ------------- |:-------------:| -----:|
| websocket | key data events: new, update, delete | ws://{host}:{port}/mo/{key} |
| POST | create/update, if the index is not provided it will autogenerate a new one, preexistent data on the provided key/index will be overwriten | http://{host}:{port}/r/mo |
| GET | get list | http://{host}:{port}/r/mo/{key} |

### websocket

### get (sent after handshake and on each new/update/delete event)
---
```js
[
    {
        created: 1546660572033308700,
        updated: 0,
        index: '1576d7988025d81c0',
        data: 'e30='
    }
    ...
]
```

### create/update (format expected from client)
    the index field is optional, will be autogenerated if its empty/null.
---
```js
{
    index: 'test',
    data: 'e30='
}
```

### delete (format expected from client)
---
```js
{
    op: 'del',
    index: 'test'
}
```

## filters and audit

    Define ad lib custom acceptance criteria of data using key glob patterns and audit middleware

```go
package main

import (
	"errors"

	"github.com/benitogf/samo"
)

func main() {
	app := samo.Server{}
	app.Static = true // limit to filtered paths
	app.ReceiveFilter("things/*", func(index string, data []byte) ([]byte, error) {
		if string(data) != "object" {
			return nil, errors.New("filtered")
		}

		return data, nil
	})

	app.ReceiveFilter("bag", func(index string, data []byte) ([]byte, error) {
		if string(data) != "marbles" {
			return nil, errors.New("filtered")
		}

		return data, nil
	})

	app.SendFilter("bag/1", func(index string, data []byte) ([]byte, error) {
		return []byte("intercepted"), nil
	})
	app.Start("localhost:8800")
	app.WaitClose()
}
```

## data persistence layer

    Use alternative storages, the default is memory

```go
package main

import (
	"sync"

	"github.com/benitogf/samo"
)

func main() {
	app := samo.Server{}
	app.Storage = &samo.LevelDbStorage{
			Path:    "data/db",
			lvldb:   nil,
			Storage: &samo.Storage{Active: false}}
	app.Start("localhost:8800")
	app.WaitClose()
}
```

    Define alternative storages

```go
package main

import (
	"errors"
	"fmt"

	"github.com/benitogf/samo"
)

type customStorage struct {
	*samo.Storage
}

// Active  :
func (db *customStorage) Active() bool {
	return db.Storage.Active
}

// Start  :
func (db *customStorage) Start(separator string) error {
	db.Storage.Separator = separator
	db.Storage.Active = true
	return nil
}

// Close  :
func (db *customStorage) Close() {
	db.Storage.Active = false
}

// Keys  :
func (db *customStorage) Keys() ([]byte, error) {
	fmt.Println("keys")
	return []byte(""), errors.New("not implemented")
}

// Get :
func (db *customStorage) Get(mode string, key string) ([]byte, error) {
	fmt.Println("get", mode, key)
	return []byte(""), errors.New("not implemented")
}

// Peek  :
func (db *customStorage) Peek(key string, now int64) (int64, int64) {
	fmt.Println("peek", key, now)
	return 0, 0
}

// Set  :
func (db *customStorage) Set(key string, index string, now int64, data string) (string, error) {
	fmt.Println("set", key, index, now, data)
	return "", errors.New("not implemented")
}

// Del  :
func (db *customStorage) Del(key string) error {
	fmt.Println("del", key)
	return errors.New("not implemented")
}

func main() {
	app := samo.Server{}
	app.Storage = &customStorage{&samo.Storage{Active: false}}
	app.Start("localhost:8800")
	app.WaitClose()
}


```
